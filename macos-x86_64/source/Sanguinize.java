/* autogenerated by Processing revision 1293 on 2025-05-14 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import gifAnimation.*;
import gifAnimation.*;
import gifAnimation.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class Sanguinize extends PApplet {



Sal s1;
Mace s;
ArrayList<Projectile> projectiles = new ArrayList<Projectile>();
ArrayList<Chud> chuds = new ArrayList<Chud>();
ArrayList<Fly> flies = new ArrayList<Fly>();

public float timeScale = 1.0f;
static public final int chudDifficulty = 1;
static public final int flyDifficulty = 1;
static public int enemyTypes;
static public Gif sIdleLeft, sIdleRight, cRun, fRun, cFall;
static public int gravity, wave, waveDifficulty, ground, enemyCount;
static public float friction;
static public char jumpKey, leftKey, rightKey, dashKey;
static private boolean start, gameRun, death, jumpKeyHeld, leftKeyHeld, rightKeyHeld, debug;
static public boolean upgrade;
PImage bloodBar;
PImage startText;
PImage startBack;
PImage mainBack;
PFont dos;
PImage dead;
public PImage maceSwing;
public static Timer dashTime, startTime, slowMo;

public void setup()
{
  upgrade = false;
  enemyTypes = 2;
  dashTime = new Timer(500);
  startTime = new Timer(500);
  slowMo = new Timer(100);
  dashTime.start();
  friction = .8f;
  jumpKey = 'w';
  leftKey = 'a';
  rightKey = 'd';
  dashKey = 'q';
  /* size commented out by preprocessor */;
  ground = height - 300;
  s1 = new Sal();
  s = new Mace();
  maceSwing = loadImage("Mace .png");
  cRun = new Gif(this, "FarmerRunning.gif");
  cFall = new Gif(this, "FarmerFALLing.gif");
  fRun = new Gif(this, "mosquito gif.gif");
  sIdleLeft = new Gif(this, "guyLeft.gif");
  sIdleRight = new Gif(this, "guyRight.gif");
  startText = loadImage("startText.png");
  startBack = loadImage("startBack.png");
  mainBack = loadImage("Map.png");
  bloodBar = loadImage("bloodBar.png");
  dead = loadImage("death.png");
  start = true;
  wave = 1;
  gravity = 5;
  waveDifficulty = 10;
  dos = createFont("PerfectDOSVGA437.ttf", 35);
  death = false;
}
public void draw()
{
  noTint();
  if (start)
  {
    startScreen();
  } else if (gameRun && !death)
  {
    controlScheme();
    infoOverlay();
    projectileDisplay();
    s1.display();
    s1.move();
    s.display(s1);
    chudDisplay();
    flyDisplay();
    timeScale = 1.0f;
    imageMode(CENTER);
    if (waveDifficulty == 0)
    {
      startWave();
    }
    if (upgrade)
    {
      upgradeScreen();
    }
    if (debug)
    {
      debug();
    }
  } else
  {
    deathScreen();
  }
}
public void mousePressed()
{
  if (mouseButton == LEFT)
  {
    println("MousePress");
    if (start)
    {
      gameRun = true;
      start = false;
      startWave();
      s1.blood = 190;
    } else if (gameRun)
    {
      s.mainAttack(s1);
      projectiles.add(new Projectile("spear", mouseX, mouseY, 10, 10, degrees(180), 40));
    } else if (death)
    {
      start = true;
      death = false;
      startWave();
      s1.blood = 190;
      wave = 1;
    }
  }
}
public void keyPressed()
{
  if (key == jumpKey || key == ' ')
  {
    jumpKeyHeld = true;
  }
  if (key == leftKey)
  {
    leftKeyHeld = true;
  }
  if (key == rightKey)
  {
    rightKeyHeld = true;
  }
  if (key == dashKey)
  {
    s1.dash();
  }
  if (key == '0')
  {
    debug = !debug;
  }
  if (key == '.')
  {
    upgrade = !upgrade;
  }
}
public void keyReleased()
{
  if (key == jumpKey || key == ' ')
  {
    jumpKeyHeld = false;
  }
  if (key == leftKey)
  {
    leftKeyHeld = false;
  }
  if (key == rightKey)
  {
    rightKeyHeld = false;
  }
}
private void projectileDisplay()
{
  for (int i = 0; i < projectiles.size(); i++)
  {
    Projectile p = projectiles.get(i);
    //p.display();
    p.move();
  }
}
private void chudDisplay()
{
  for (int i = 0; i < chuds.size(); i++)
  {
    Chud c = chuds.get(i);
    c.display();
    c.move(chuds);
    c.cooldown();
    c.playerCheck();
    if (c.hp < 1)
    {
      chuds.remove(c);
      waveDifficulty -= 1;
    }
  }
}
private void flyDisplay()
{
  for (int i = 0; i < flies.size(); i++)
  {
    Fly f = flies.get(i);
    f.display();
    f.move();
    f.cooldown();
    f.playerCheck();
    if (f.hp < 1)
    {
      flies.remove(f);
      waveDifficulty -= 1;
    }
  }
}
public void controlScheme()
{
  if (jumpKeyHeld)
  {
    s1.jump();
  }
  if (leftKeyHeld)
  {
    s1.walk(-3);
  }
  if (rightKeyHeld)
  {
    s1.walk(3);
  }
}
private void startWave()
{
  wave ++;
  waveDifficulty = (int)Math.pow(1.66f, wave);
  for (int i = 0; i < waveDifficulty; )
  {
    int enemySelect = (int)(Math.random() * enemyTypes);
    if (enemySelect == 0)
    {

      if (!(i + chudDifficulty > waveDifficulty))
      {
        spawn("Chud");
        i += chudDifficulty;
      }
    } else if (enemySelect == 1)
    {

      if (!(i + flyDifficulty > waveDifficulty))
      {
        spawn("Fly");
        i += flyDifficulty;
      }
    }
  }
}
private void startScreen()
{
  imageMode(CORNER);
  image(startBack, 0, 0);
  imageMode(CENTER);
  image(startText, width / 2, height / 2);
}

private void infoOverlay()
{
  imageMode(CORNER);
  image(mainBack, 0, 0);
  fill(100, 50);
  rect(width / 2 - 390, 30, 775, 15);
  fill(255, 0, 0, 100);
  rectMode(CORNER);
  rect(width / 2 - 390, 30, s1.blood * (750f / s1.maxBlood), 15);
  imageMode(CENTER);
  image(bloodBar, width / 2, 35);
}
private void upgradeScreen()
{
  timeScale = 0.05f;
  if (slowMo.isFinished()) slowMo.start();
  timeScale = lerp(timeScale, 1.0f, 0.05f);
  if (slowMo.isFinished()) upgrade = false;
  //rectMode(CORNER);
  //fill(100, 50);
  //rect(0, 0, width, height);
  //rectMode(CENTER);
  //rect(width / 6.0, height / 2, 500, height / 1.25);
  //rect(width / 2, height / 2, 500, height / 1.25);
  //rect(width * (5.0/6.0), height / 2, 500, height / 1.25);
}
private void deathScreen()
{
  imageMode(CORNER);
  image(dead, 0, 0);
}
private static void runMusic()
{
}
private void debug()
{
  imageMode(CORNER);
  text("ENEMY COUNT: " + enemyCount, 20, 20);
  text("WAVE: " + wave, 20, 40);
  text("WAVE DIFFICULTY: " + waveDifficulty, 20, 60);
}
private void spawn(String name)
{
  float side = ((float)(Math.random() * 1) - 0.5f) * 1000000;
  if (name.equals("Chud"))
  {
    println("spawning chud");
    chuds.add(new Chud(side * 2 * width));
  }
  if (name.equals("Fly"))
  {
    flies.add(new Fly(side * 2 * width));
    println("spawning fly");
  }
}

public class Chud extends enemies

{
  Gif c1;
  final Timer chudCooldown = new Timer(800);
  final Timer chudRampup = new Timer(400);
  final Timer chudDamaging = new Timer(400);
  float aDirection;
  Chud(float x)
  {
    hp = 1;
    damage = 25;
    isAttacking = false;
    walking = true;
    this.x = x;
    y = height / 2;
    eWidth = (int)(Math.random() * 10) + 45;
    eHeight = (int)(Math.random() * 10) + 45;
    name = "Chud";
    walkSpeed = (float)(Math.random() * 1.0f) + 1.5f;
    enemyCount++;
    waveReq = 1;
  }
  public void display()
  {
    imageMode(CENTER);
    
    cRun.play();
    tint(0);
    if (direction == 1 && walking)
    {
      noTint();
      image(cRun, x, y, eWidth, eHeight);
    } else if (direction == -1 && walking)
    {
      pushMatrix();
      translate(x, y);
      scale(-1, 1);
      noTint();
      image(cRun, 0, 0, eWidth, eHeight);
      popMatrix();
    } else if (aDirection == 1)
    {
      cFall.play();
      noTint();
      image(cFall, x, y, eWidth, eHeight);
    } else if (aDirection == -1)
    {
      cFall.play();
      pushMatrix();
      translate(x, y);
      scale(-1, 1);
      noTint();
      image(cFall, 0, 0, eWidth, eHeight);
      popMatrix();
    }
  }
  public void move(ArrayList<Chud> others)
  {
    if (isAttacking) walking = false;
    fall();
    if (walking) walk();
    x += xSpeed * timeScale;
    y += ySpeed * timeScale;
    attack();
    xSpeed *= friction * timeScale;
    ySpeed *= friction * timeScale;
    borderCheck();
    avoidClumping(others);
  }
  public void playerCheck()
  {
    if (abs(s1.x - x) < 150 && !isAttacking)
    {
      startAttack();
    }
    if (abs(s1.x - x) < 50 && damaging)
    {
      damaging = false;
      s1.damage(damage);
    }
  }
  private void walk()
  {

    direction = ((s1.x - x) / abs(s1.x - x));
    xSpeed += walkSpeed * direction;
  }
  private void fall()
  {
    if (inAir)
    {
      ySpeed += gravity * timeScale;
    }
  }
  private void borderCheck()
  {
    if (x < eWidth)
    {
      x = 0 + eWidth;
    }
    if (x > width - eWidth)
    {
      x = width - eWidth;
    }
    if (y >= ground)
    {
      inAir = false;
      y = ground;
      if (ySpeed > 0)
      {
        ySpeed = 0;
      }
    } else
    {
      inAir = true;
    }
  }
  public void startAttack()
  {
    if (!isAttacking && chudCooldown.isFinished())
    {
      cFall.jump(0);
      isAttacking = true;
      walking = false;
      println("starting attack");
      println("stopped walking");
      aDirection = ((s1.x - x) / abs(s1.x - x));
      chudRampup.start();
    }
  }
  public void attack()
  {
    if (chudRampup.isFinished() && isAttacking)
    {
      damaging = true;
      println("attacking");
      xSpeed = 50 * aDirection;
      isAttacking = false;
      chudDamaging.start();
      ;
      chudCooldown.start();
      walking = false;
    }
  }
  public void cooldown()
  {
    if (chudDamaging.isFinished())
    {
      damaging = false;
    }
    if (chudCooldown.isFinished())
    {
      walking = true;
    }
  }
  public void damage(int damage)
  {
    hp -= damage;
    s1.blood += damage * 50;
  }
  public void avoidClumping(ArrayList<Chud> others) {
  for (Chud other : others) {
    if (other != this) {
      float dx = x - other.x;
      float dy = y - other.y;
      float distance = dist(x, y, other.x, other.y);
      float minDist = (eWidth + other.eWidth) / 2;

      if (distance < minDist && distance > 0) {
        float overlap = minDist - distance;
        float pushX = (dx / distance) * (overlap / 2);
        float pushY = (dy / distance) * (overlap / 2);
        x += pushX;
        y += pushY;
        other.x -= pushX;
        other.y -= pushY;
      }
    }
  }
}

}

public class Fly extends enemies

{
  Gif f1;
  final Timer flyCooldown = new Timer(400);
  final Timer flyRampup = new Timer(200);
  final Timer flyDamaging = new Timer(300);
  float yDirection;
  float xDirection;
  float yLoc;
  float mainWalkSpeed;
  Fly(float x)
  {
    hp = 1;
    damage = 10;
    isAttacking = false;
    walking = true;
    this.x = x;
    y = height / 2;
    eWidth = (int)(Math.random() * 10) + 45;
    eHeight = (int)(Math.random() * 10) + 45;
    name = "Fly";
    mainWalkSpeed = (float)(Math.random() * 0.5f) + 2;
    enemyCount++;
    waveReq = 1;
    isStunned = false;
    falling = false;
    f1 = fRun;
  }
  public void display()
  {
    imageMode(CENTER);

    f1.play();
    noTint();
    image(f1, x, y, eWidth, eHeight);
  }
  public void move()
  {
      if (isAttacking) walking = false;
      if (walking) walk();
      x += xSpeed * timeScale;
      y += ySpeed * timeScale;
      attack();
      xSpeed *= friction * timeScale;
      ySpeed *= friction * timeScale;
      borderCheck();
      y -= sin(radians(frameCount * 5)) * 0.5f * timeScale;

  }
  public void playerCheck()
  {
    if (abs(s1.x - x) < 150 && !isAttacking)
    {
      startAttack();
    }
    if (abs(s1.x - x) < 50 && damaging)
    {
      damaging = false;
      s1.damage(damage);
    }
  }
  private void walk()
  {

    direction = ((s1.x - x) / abs(s1.x - x));
    xSpeed += walkSpeed * direction;
    yLoc = (float)(Math.random() * 100 + 450);
    if(y > yLoc)
    {
      ySpeed -= 2;
      walkSpeed = mainWalkSpeed * .5f;
      //ySpeed -= cos(atan2(height / 2 - y, s1.x - x))* 2;
    }
    else
    {
      walkSpeed = mainWalkSpeed;
      ySpeed += 0.5f;
    }
  }

  private void borderCheck()
  {
    if (x < eWidth)
    {
      x = 0 + eWidth;
    }
    if (x > width - eWidth)
    {
      x = width - eWidth;
    }
    if (y >= ground)
    {
      inAir = false;
      y = ground;
      if (ySpeed > 0)
      {
        ySpeed = 0;
      }
    } else
    {
      inAir = true;
    }
  }
  public void startAttack()
  {
    if (!isAttacking && flyCooldown.isFinished())
    {
      isAttacking = true;
      walking = false;
      println("starting attack");
      println("stopped walking");
      float angle = atan2(s1.y-y, s1.x-x);
      xDirection = cos(angle) * 32;
      yDirection = sin(angle) * 32;
      flyRampup.start();
    }
  }
  public void attack()
  {
    if (flyRampup.isFinished() && isAttacking)
    {
      damaging = true;
      println("attacking");

      isAttacking = false;
      flyDamaging.start();
      xSpeed += xDirection;
      ySpeed += yDirection;
      flyCooldown.start();
      walking = false;
    }
  }
  public void cooldown()
  {
    if (flyDamaging.isFinished())
    {
      damaging = false;
    }
    if (flyCooldown.isFinished())
    {
      walking = true;
      ySpeed = 0;
    }
  }
  public void damage(int damage)
  {
    hp -= damage;
    s1.blood += damage * 50;
  }
}

public class Mace extends Weapon {
  float angle = 0; // Track rotation angle
  boolean isSwinging = false; // Track if the mace is swinging
  PImage maceSwing;
  int launchHeight;
  int launchDist;
  float x;
  float y;
  Mace() {
    x = 0;
    y = 0;
    name = "Mace";
    damage = 1;  // Example damage value
    cooldown = 500;
    available = true;
    onCooldown = false;
    maceSwing = loadImage("Mace .png");
    launchHeight = 75;
    launchDist = 10;
  }

  final Timer mCooldown = new Timer(cooldown);
  final Timer attackDuration = new Timer(200);  // Timer for the duration of the attack animation

  public void mainAttack(Sal s) {
    // Check if the mace is on cooldown
    if (onCooldown) {
      if (mCooldown.isFinished()) {
        onCooldown = false;
        mCooldown.start();
      } else {
        return; // Still cooling down
      }
    }

    // Start cooldown
    onCooldown = true;
    mCooldown.start();

    // Trigger the attack animation (start the timer for the mace attack duration)
    s.isAttacking = true;
    attackDuration.start();  // Start the attack duration timer
    isSwinging = true; // Start the swinging animation

    // Reset angle to start a fresh swing on each attack
    if (s.direction.equals("left")) angle = 120;
    else angle = -120;

    // Handle damage and collision (we'll assume the player's hitbox is a simple rectangle)
    if (s1.direction.equals("left")) {
      // Check if any enemy is in range
      for (Chud c : chuds) {
        if (dist(x - 10, y, c.x, c.y) < 60 && s.isAttacking) {  // Example distance for hit detection
          c.damage(damage);  // Deal damage to the enemy
          // Apply force to the player (Sal) when the attack hits an enemy
          s.xSpeed -= launchDist; // Adjust xSpeed
          s.ySpeed -= launchHeight; // Apply upward force to launch the player
          s.isAttacking = false;
          mCooldown.decrease(250);
        }
      }
      for (Fly f : flies) {
        if (dist(x - 10, y, f.x, f.y) < 60 && s.isAttacking) {  // Example distance for hit detection
          f.damage(damage);  // Deal damage to the enemy
          // Apply force to the player (Sal) when the attack hits an enemy
          s.xSpeed -= launchDist; // Adjust xSpeed
          s.ySpeed -= launchHeight; // Apply upward force to launch the player
          s.isAttacking = false;
          mCooldown.decrease(250);
        }
      }
    } else {
      // Right-facing hitbox logic
      for (Chud c : chuds) {
        if (dist(x + 10, y, c.x, c.y) < 60 && s.isAttacking) {
          c.damage(damage);
          // Apply force to the player (Sal) when the attack hits an enemy
          s.xSpeed += launchDist; // Adjust xSpeed
          s.ySpeed -= launchHeight; // Apply upward force to launch the player
          s.isAttacking = false;
          mCooldown.decrease(250);
        }
      }
      for (Fly f : flies) {
        if (dist(x + 10, y, f.x, f.y) < 60 && s.isAttacking) {
          f.damage(damage);
          // Apply force to the player (Sal) when the attack hits an enemy
          s.xSpeed += launchDist; // Adjust xSpeed
          s.ySpeed -= launchHeight; // Apply upward force to launch the player
          s.isAttacking = false;
          mCooldown.decrease(250);
        }
      }
    }
  }

  // Display the mace swing when the player is attacking
  public void display(Sal s) {
    x = s.x;
    y = s.y;
    if (s.isAttacking) {
      imageMode(CENTER);

      // Rotate the mace as it swings (clockwise or counterclockwise based on direction)
      if (isSwinging) {
        if (s.direction.equals("left")) {
          // Counterclockwise rotation when facing left (negative angle)
          angle -= 20 * timeScale; // Adjust rotation speed here (negative for counterclockwise)
        } else {
          // Clockwise rotation when facing right (positive angle)
          angle += 20 * timeScale; // Adjust rotation speed here (positive for clockwise)
        }

        // Stop the swinging after a full rotation (360 degrees)
        if (Math.abs(angle) >= 240) {
          angle = 120;
          isSwinging = false;
        }
      }

      // Depending on the player's direction, adjust the position of the mace
      if (s.direction.equals("left")) {
        // Position for left-facing direction (handle stays near player)
        pushMatrix();
        translate(x - 10, y);  // Adjust for the handle's position near the player
        rotate(radians(angle));   // Rotate around the base of the handle
        image(maceSwing, 0, -30);  // Draw mace head; Adjust the -30 to fine-tune position
        popMatrix();
      } else {
        // Position for right-facing direction (handle stays near player)
        pushMatrix();
        translate(x + 10, y);  // Adjust for the handle's position near the player
        rotate(radians(angle));   // Rotate around the base of the handle
        image(maceSwing, 0, -30);  // Draw mace head; Adjust the -30 to fine-tune position
        popMatrix();
      }
    }

    // If the attack duration is over, stop the animation and reset the angle
    if (attackDuration.isFinished()) {
      s.isAttacking = false;  // Reset the attacking state after animation
      angle = 0;  // Reset the angle after each attack
    }
  }
}
public class Sal
{
  Gif s1;
  private float xSpeed, ySpeed, dashSpeed;
  public float x, y, totalBlood;
  private int sWidth, sHeight, jumpHeight, flashes, tempFlashes, level;
  private float bloodDrain;
  public float blood, maxBlood;
  private String weaponSelected, currentAction;
  private boolean isDashing, inAir, isAttacking, isHit, iFrame, isDead, flashing;
  public String direction = "left";
  final private Timer dashFrames = new Timer(100);
  final private Timer damageFrames = new Timer(100);
  final private Timer flashFrames = new Timer(100);
  Sal()
  {
    level = 1;
    flashing = false;
    tempFlashes = 0;
    maxBlood = 200;
    x = width / 2;
    y = height / 2;
    jumpHeight = 20;
    sWidth = 18;
    sHeight = 100;
    blood = 190;
    totalBlood = 0;
    dashSpeed = 30;
    bloodDrain = 0.1f;
  }

  public void display()
  {
    if (dashFrames.isFinished() && damageFrames.isFinished()) iFrame = false;
    if (flashFrames.isFinished()) flashing = false;
    imageMode(CENTER);
    if (mouseX < x)
    {
      sIdleLeft.play();
      direction = "left";
      if (flashing) tint(255, 0, 0);
      image(sIdleLeft, x, y);
      noTint();
    } else
    {
      direction = "right";
      sIdleRight.play();
      if (flashing) tint(255, 0, 0);
      image(sIdleRight, x, y);
      noTint();
    }
    if (y >= ground)
    {
      inAir = false;
      y = ground;
      if (ySpeed > 0)
      {
        ySpeed = 0;
      }
    } else
    {
      inAir = true;
    }
    if (blood >= maxBlood)
    {
      upgrade = true;
      level ++;
      bloodDrain = level / 10.0f;
      maxBlood = 200 * level;
      blood = maxBlood / 2;
    }
    if (gameRun) blood -= bloodDrain * timeScale;
    if (blood < 0) {
      death = true;
      gameRun = false;
    }
  }
  public void move()
  {
    x += xSpeed * timeScale;
    y += ySpeed * (timeScale);
    if (inAir)
    {
      ySpeed += gravity * timeScale;
    }
    xSpeed *= pow(friction, timeScale);
    ySpeed *= pow(friction, timeScale);
    if (x < sWidth)
    {
      x = 0 + sWidth;
    }
    if (x > width - sWidth)
    {
      x = width - sWidth;
    }
  }
  public void walk(int tempX)
  {
    xSpeed += tempX * timeScale;
    if (tempX < 0)
    {
      direction = "left";
    } else
    {
      direction = "right";
    }
  }
  public void dash()
  {
    if (dashTime.isFinished())
    {
      if (direction == "left")
      {
        xSpeed -= dashSpeed;
        iFrame = true;
        dashFrames.start();
        dashTime.start();
      } else
      {
        xSpeed += dashSpeed;
        iFrame = true;
        dashFrames.start();
        dashTime.start();
      }
    }
  }
  public void jump()
  {
    if (!inAir)
    {
      ySpeed -= jumpHeight;
    }
  }
  public void bloodWield() {
  }
  public void damage(int damage)
  {
    if (!iFrame)
    {
      blood -= damage;
      damageFrames.start();
      iFrame = true;
      flash();
    }
  }
  public void flash()
  {
    flashing = true;
    flashFrames.start();
  }
}
// Timer || Daniel Shiffman

class Timer {

  int savedTime; // When Timer started
  int totalTime; // How long Timer should last

  Timer(int tempTotalTime) {
    totalTime = tempTotalTime;
  }

  // Starting the timer
  public void start() {
    // When the timer starts it stores the current time in milliseconds.
    savedTime = millis();
  }
  public void decrease(int tempTime)
  {
    savedTime -= tempTime;
  }

  // The function isFinished() returns true if 5,000 ms have passed. 
  // The work of the timer is farmed out to this method.
  public boolean isFinished() { 
    // Check how much time has passed
    float passedTime = (millis()- savedTime) * timeScale;
    if (passedTime > totalTime) {
      return true;
    } else {
      return false;
    }
  }
}
public abstract class enemies
{
  float x, y, xSpeed, ySpeed, walkSpeed, direction;
  int hp, speed, eWidth, eHeight, waveReq, damage;
  boolean isStunned, isAttacking, inAir, damaging, falling;
  String name;
  boolean walking;
}
public class Projectile {
    private int x, y, speed, damage, radius;
    private double direction;
    private boolean isActive, hasStunEffect;
    private String type;

    public Projectile(String type, int startX, int startY, int speed, int damage, double direction, int radius) {
        this.type = type;
        this.x = startX;
        this.y = startY;
        this.speed = speed;
        this.damage = damage;
        this.direction = direction;
        this.radius = radius;
        this.isActive = true;
        this.hasStunEffect = type.equals("bullet");
    }
    public void move() {
        if (!isActive) return;
        x += (int) (speed * Math.cos(direction));
        y += (int) (speed * Math.sin(direction));
    }

    public boolean checkHit(int targetX, int targetY, int targetRadius) {
        if (!isActive) return false;
        double distance = Math.sqrt(Math.pow(targetX - x, 2) + Math.pow(targetY - y, 2));
        return distance < targetRadius + radius;
    }

    //public void applyEffect(Player player) {
    //    if (!isActive) return;
    //    if (type.equals("spear") && checkHit(player.getX(), player.getY(), player.getRadius())) {
    //        player.takeDamage(damage);
    //        deactivate();
    //    } else if (type.equals("bullet") && checkHit(player.getX(), player.getY(), player.getRadius())) {
    //        player.takeDamage(damage);
    //        player.stun();
    //        deactivate();
    //    }
   // }

    public int getDamage() {
        return damage;
    }

    public boolean isActive() {
        return isActive;
    }

    public void deactivate() {
        isActive = false;
    }

    public int getX() {
        return x;
    }

    public int getY() {
        return y;
    }
}
public abstract class Weapon {
  String name;
  int damage;
  int cooldown;
  int bloodCost;
  boolean available;
  boolean onCooldown;
  float direction;

//  public Weapon(String name, int damage, int cooldown, int bloodCost) {
 //   this.name = name;
//    this.damage = damage;
//    this.cooldown = cooldown;
//    this.bloodCost = bloodCost;
//    this.available = true;
//    this.onCooldown = false;
//  }

  public boolean canUse() {
    return !onCooldown;
  }

  public abstract void mainAttack(Sal s);
  //public abstract void bloodwield(Sal s, Weapon name);
}


  public void settings() { size(1720, 900); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "Sanguinize" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
